image: node:8

stages:
    - build_package
    - test
    - test_functional
    - build
    - publish

variables:
    TERRAFORM_PKG_URL: 'https://releases.hashicorp.com/terraform/0.12.6/terraform_0.12.6_linux_386.zip'
    # azure vars - normalize env var options between ansible and terraform
    AZURE_TENANT: "$AZURE_TENANT_ID"
    AZURE_SECRET: "$AZURE_CLIENT_SECRET"
    ARM_CLIENT_ID: "$AZURE_CLIENT_ID"
    ARM_CLIENT_SECRET: "$AZURE_CLIENT_SECRET"
    ARM_SUBSCRIPTION_ID: "$AZURE_SUBSCRIPTION_ID"
    ARM_TENANT_ID: "$AZURE_TENANT_ID"
    # aws vars
    AWS_ACCESS_KEY_ID: "$AWS_ACCESS_KEY_ID"
    AWS_SECRET_ACCESS_KEY: "$AWS_SECRET_ACCESS_KEY"
    AWS_DEFAULT_REGION: "$AWS_DEFAULT_REGION"
    # gcp vars
    GOOGLE_CREDENTIALS: "$GOOGLE_CREDENTIALS"
    # debug vars
    F5_SDK_LOG_LEVEL: "INFO"
    PYTHONWARNINGS: 'ignore:Unverified HTTPS request'

build_package:
    image: f5devcentral/containthedocs:rpmbuild
    stage: build_package
    script:
        - echo 'CI BUILD'
        # install packages: jq
        - apt-get update
        - apt-get install -y jq
        # install node modules
        - npm run install-production
        - bash ./scripts/build_rpm.sh
    tags:
        - cm-official-docker-executor
    artifacts:
        name: f5-cloud-failover-$CI_BUILD_REF
        paths:
            - dist
        expire_in: 1 month

test_node4:
    stage: test
    image: node:4  
    script:
        - npm install --global npm@5.10.0
        - npm install mocha@5.2.0
        - npm install nyc@14.0.0
        - npm install --no-optional
        - npm run test-only-node-4
    tags:
        - docker-executor

test_package:
    stage: test
    script:
        # install jq
        - apt-get update
        - apt-get install -y jq
        # install node modules
        - npm install
        # npm audit - install includes audit, but perform specific check and fail if needed
        - audit_report=$(npm audit --json)
        - echo $audit_report
        - actions=$(echo $audit_report | jq .actions | jq length)
        - if [ $actions -ne 0 ]; then echo 'ERROR! vulnerabilities exist'; exit 1; fi
        # linter
        - npm run lint
        # unit tests
        - npm run test && npm run check && npm run report
    tags:
        - cm-official-docker-executor
    artifacts:
        name: ${CI_COMMIT_REF_NAME}_unittests_coverage
        paths:
            - coverage

.test_functional_generic: &test_functional_generic
    stage: test_functional
    image: python:3
    script:
        # install jq
        - apt-get update
        - apt-get install -y jq
        # install terraform
        - curl ${TERRAFORM_PKG_URL} -o terraform.zip -vvv && unzip terraform.zip && export PATH="$PATH:$(pwd)"
        # install node (and package dependencies)
        - curl -sL https://deb.nodesource.com/setup_10.x | bash - && apt-get -y install nodejs
        - npm install
        # setup environment
        - npm run deployment-create
        # run functional tests
        - npm run test-functional
        # run API smoke tests
        - npm run validate-api
        # teardown environment
        - npm run deployment-delete
    tags:
        - cm-official-docker-executor

# run functional tests: azure
test_functional_azure:
    <<: *test_functional_generic
    variables:
        CF_ENV_CLOUD: "azure"

# run functional tests: aws
test_functional_aws:
    <<: *test_functional_generic
    variables:
        CF_ENV_CLOUD: "aws"

# run functional tests: gcp
# note: disabled until quota for compute network and subnetwork limit is increased
.test_functional_gcp:
    <<: *test_functional_generic
    variables:
        CF_ENV_CLOUD: "gcp"

build_docs:
    image: python:3.7
    stage: build
    script:
        # install packages
        - pip install -r requirements.txt
        # generate docs
        - make html
    tags:
        - docker-executor
    artifacts:
        name: docs
        paths:
            - docs/_build/html
        expire_in: 1 month

build_api_docs:
    stage: build
    script:
        # install packages
        - npm install
        # generate docs
        - npm run make-api-docs
        - mkdir apidocs && mv redoc-static.html apidocs/index.html
    tags:
        - docker-executor
    artifacts:
        name: docs
        paths:
            - apidocs
        expire_in: 1 month

publish_to_artifactory:
    stage: publish
    only:
        - tags
    tags:
        - cm-official-docker-executor
    script:
        # If the tag contains a '-', then get RPM from the build artifact, otherwise, get it from dist
        # since no '-' in the tag means it's s release and should have been committed to dist.
        - if [[ $CI_COMMIT_TAG == *"-"* ]]; then
        -     RPM_FILE=$(ls build/rpmbuild/RPMS/noarch/*.rpm)
        - else
        -     RPM_FILE=$(ls dist/new_build/*.rpm)
        - fi
        - RPM_NAME=$(basename $RPM_FILE)
        - URL=${ARTIFACTORY_BASE_URL}/ecosystems-f5-cloud-failover-rpm/${RPM_NAME}
        - >-
            UPLOAD_RESULT=$(curl -H "Authorization: Bearer ${ARTIFACTORY_BEARER_TOKEN}" -X PUT --data-binary @${RPM_FILE} ${URL})
        - if [[ $? -eq 0 ]] && [[ "$UPLOAD_RESULT" == *created* ]]; then echo "Upload complete"; else echo "Upload failed"; exit 1; fi
        - echo $UPLOAD_RESULT

# publish docs to internal pages: - this job MUST be named 'pages'
pages:
    stage: publish
    environment:
        name: staging
        url: https://${CI_PROJECT_NAMESPACE}.${PAGES_DOMAIN}/${CI_PROJECT_NAME}   
    script:
        - PUBLIC_DIR='./public'
        - mkdir -p ${PUBLIC_DIR}
        # place index.html in public dir
        - cp docs/index.html ${PUBLIC_DIR}/index.html
        #### place public facing docs under: /public-docs ####
        - PUBLIC_DOCS=${PUBLIC_DIR}/public-docs
        - mkdir -p ${PUBLIC_DOCS}
        - cp -R docs/_build/html/* ${PUBLIC_DOCS}
        #### place API docs under: /api-docs ####
        - API_DOCS=${PUBLIC_DIR}/api-docs
        - mkdir -p ${API_DOCS}
        - cp -R apidocs/* ${API_DOCS}
        #### place code coverage docs under: /coverage-docs ####
        - COVERAGE_DOCS=${PUBLIC_DIR}/coverage
        - mkdir -p ${COVERAGE_DOCS}
        - cp -R coverage/* ${COVERAGE_DOCS}
        #### place code contribution docs (mainly for presentation) under: /contribute-docs ####
        - CONTRIBUTE_DOCS=${PUBLIC_DIR}/contribute-docs
        - CONTRIBUTE_DIR=contributing
        # install presentation site dependencies
        - cd ${CONTRIBUTE_DIR} && npm install && cd ..
        - mkdir -p ${CONTRIBUTE_DOCS}
        - cp -R ${CONTRIBUTE_DIR}/* ${CONTRIBUTE_DOCS}
        # make relative links absolute - this could be better...
        # ![diagram](../test/README.md) -> ![diagram](https://base.url/../test/README.md)
        - BASE_URL_FOR_LINKS=${CI_PROJECT_URL}/tree/${CI_COMMIT_REF_NAME}/${CONTRIBUTE_DIR}/
        - README=${CONTRIBUTE_DOCS}/README.md
        # make absolute URL(s) for relative URL(s) outside current directory '../'
        - sed -i -E 's/\[.*\]\(\.\./&SED_TEMP/' ${README} && sed -i "s|..SED_TEMP|${BASE_URL_FOR_LINKS}..|" ${README}
    tags:
        - cm-official-docker-executor
    artifacts:
        paths:
            - public
    only:
        - master
        - develop

# Publish docs to clouddocs.f5.com
docs to production:
  image: ${CONTAINTHEDOCS_IMAGE}
  stage: publish
  environment:
    name: production
    url: https://clouddocs.f5.com/products/extensions/f5-cloud-failover/latest
  only:
  # Currently will only deploy to clouddocs.f5.com on commits to doc-publish
  # fill in desired release branch name and uncomment to add deployment from a branch
  - docs-publish@cloudsolutions/f5-cloud-failover
  tags:
  - cm-official-docker-executor
  dependencies:
  - build_docs
  script:
  # Uncomment and set to create desired version format
    - aws s3 sync docs/_build/html s3://clouddocs.f5.com/products/extensions/f5-cloud-failover/latest
    # create invalidation to clear cloudfront cache
    - aws cloudfront create-invalidation --distribution-id $AWS_DIST --paths /products/extensions/f5-cloud-failover/latest

