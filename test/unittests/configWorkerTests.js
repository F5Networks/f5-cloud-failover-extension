/*
 * Copyright 2019. F5 Networks, Inc. See End User License Agreement ("EULA") for
 * license terms. Notwithstanding anything to the contrary in the EULA, Licensee
 * may copy and modify this software product for its internal business purposes.
 * Further, Licensee may upload, publish and distribute the modified version of
 * the software product on devcentral.f5.com.
 */

'use strict';

/* eslint-disable global-require */

const assert = require('assert');
const sinon = require('sinon');
const constants = require('../constants.js');
const Device = require('../../src/nodejs/device');

const declaration = constants.declarations.basic;
const restWorker = constants.restWorker;
const invalidRestWorker = constants.invalidRestWorker;

describe('Config Worker', () => {
    let config;
    let mockExecuteBigIpBashCmd;

    before(() => {
        config = require('../../src/nodejs/config.js');
    });
    beforeEach(() => {
        sinon.stub(Device.prototype, 'init').resolves();
        mockExecuteBigIpBashCmd = sinon.stub(Device.prototype, 'executeBigIpBashCmd').resolves();
    });
    after(() => {
        Object.keys(require.cache).forEach((key) => {
            delete require.cache[key];
        });
    });
    afterEach(() => {
        sinon.restore();
    });

    it('should process request', () => config.init(restWorker)
        .then(() => config.processConfigRequest(declaration))
        .then((response) => {
            assert.strictEqual(response.class, declaration.class);
        }));

    it('validate error case for init method', () => config.init(invalidRestWorker)
        .then(() => {
            // fails in a case when promise is resolved
            assert.fail();
        })
        .catch(() => {
            // succeeds when error recieved
            assert.ok(true);
        }));

    it('validate error case for setConfig method', () => {
        const mockConfig = {

        };
        config._restWorker = sinon.stub();
        config._restWorker.saveState = sinon.stub().callsFake((first, state, callback) => {
            callback(true);
        });
        return config.setConfig(mockConfig)
            .then(() => {
                // fails in a case when promise is resolved
                assert.fail();
            })
            .catch(() => {
                // succeeds when error recieved
                assert.ok(true);
            });
    });

    it('should reject invalid declaration', () => config.init(restWorker)
        .then(() => config.processConfigRequest({ foo: 'bar' }))
        .then(() => {
            assert.fail('Should throw an error');
        })
        .catch((err) => {
            if (err.message.includes('Invalid declaration')) return Promise.resolve();

            return Promise.reject(err);
        }));

    it('should send failover script to device executeBigIpBashCmd', () => {
        let bashCommand;
        const script = 'curl localhost';

        // Stub config's generateTriggerScript() to easily validate command passed into executeBigIpBashCmd()
        sinon.stub(Object.getPrototypeOf(config), 'generateTriggerScript').returns(script);
        mockExecuteBigIpBashCmd.callsFake((command) => {
            bashCommand = command;
            return Promise.resolve();
        });

        return config.init(restWorker)
            .then(() => {
                config.processConfigRequest(declaration);
            })
            .then(() => {
                assert.strictEqual(bashCommand, script);
            });
    });

    it('should get config', () => config.init(restWorker)
        .then(() => config.processConfigRequest(declaration))
        .then(() => config.getConfig())
        .then((response) => {
            assert.strictEqual(response.config.class, declaration.class);
        }));

    it('should reject if poorly formatted', () => {
        const errMsg = 'no bigip here';
        mockExecuteBigIpBashCmd.rejects(new Error(errMsg));
        return config.init(restWorker)
            .then(() => config.processConfigRequest(declaration))
            .then(() => {
                assert.fail('processConfigRequest() should have caught and rejected.');
            })
            .catch((err) => {
                assert.ok(true);
                assert.strictEqual(err.message, errMsg);
            });
    });

    describe('Bash trigger script generation', () => {
        it('should check for existing curl comamnd', () => {
            const scriptPath = '/tmp/test/script';
            return config.init(restWorker)
                .then(() => config.generateTriggerScript(scriptPath))
                .then((response) => {
                    // Fetch parts of formatted bash string
                    const checkCmd = response.split('; then echo ')[0];
                    const expected = `'if [[ -z $(grep "# Autogenerated by F5 Failover Extension - Triggers failover" ${scriptPath}) ]]`;
                    assert.strictEqual(checkCmd, expected);
                });
        });

        it('should echo trigger script contents', () => config.init(restWorker)
            .then(() => config.generateTriggerScript('/tmp/test/script'))
            .then((response) => {
                // Fetch parts of formatted bash string
                const echoCmd = response.split('; then echo ')[1].split('\n');
                const staticComment = echoCmd[1];
                const curlParts = echoCmd[2].split(' >> ');
                const curlCmd = curlParts[0];
                const output = curlParts[1];
                assert.strictEqual(staticComment, '# Autogenerated by F5 Failover Extension - Triggers failover');
                assert.strictEqual(curlCmd, 'curl -u admin:admin localhost:8100/mgmt/shared/cloud-failover/trigger"');
                assert.strictEqual(output, '/tmp/test/script; fi\'');
            }));
    });
});
