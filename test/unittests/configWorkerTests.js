/*
 * Copyright 2019. F5 Networks, Inc. See End User License Agreement ("EULA") for
 * license terms. Notwithstanding anything to the contrary in the EULA, Licensee
 * may copy and modify this software product for its internal business purposes.
 * Further, Licensee may upload, publish and distribute the modified version of
 * the software product on devcentral.f5.com.
 */

'use strict';

/* eslint-disable global-require */

const assert = require('assert');
const sinon = require('sinon'); /* eslint-disable-line import/no-extraneous-dependencies */
const constants = require('../constants.js');
const Device = require('../../src/nodejs/device');

const declaration = constants.declarations.basic;
const restWorker = constants.restWorker;
const invalidRestWorker = constants.invalidRestWorker;

describe('Config Worker', () => {
    let config;
    let mockExecuteBigIpBashCmd;

    before(() => {
        config = require('../../src/nodejs/config.js');
    });
    beforeEach(() => {
        sinon.stub(Device.prototype, 'init').resolves();
        mockExecuteBigIpBashCmd = sinon.stub(Device.prototype, 'executeBigIpBashCmd').resolves('');
    });
    after(() => {
        Object.keys(require.cache).forEach((key) => {
            delete require.cache[key];
        });
    });
    afterEach(() => {
        sinon.restore();
    });

    it('should process request', () => config.init(restWorker)
        .then(() => config.processConfigRequest(declaration))
        .then((response) => {
            assert.strictEqual(response.class, declaration.class);
        }));

    it('validate error case for init method', () => config.init(invalidRestWorker)
        .then(() => {
            // fails in a case when promise is resolved
            assert.fail();
        })
        .catch(() => {
            // succeeds when error recieved
            assert.ok(true);
        }));

    it('validate error case for setConfig method', () => {
        const mockConfig = {

        };
        config._restWorker = sinon.stub();
        config._restWorker.saveState = sinon.stub().callsFake((first, state, callback) => {
            callback(true);
        });
        return config.setConfig(mockConfig)
            .then(() => {
                // fails in a case when promise is resolved
                assert.fail();
            })
            .catch(() => {
                // succeeds when error recieved
                assert.ok(true);
            });
    });

    it('should reject invalid declaration', () => config.init(restWorker)
        .then(() => config.processConfigRequest({ foo: 'bar' }))
        .then(() => {
            assert.fail('Should throw an error');
        })
        .catch((err) => {
            if (err.message.includes('Invalid declaration')) return Promise.resolve();

            return Promise.reject(err);
        }));

    it('should get config', () => config.init(restWorker)
        .then(() => config.processConfigRequest(declaration))
        .then(() => config.getConfig())
        .then((response) => {
            assert.strictEqual(response.class, declaration.class);
        }));

    it('should reject if poorly formatted', () => {
        const errMsg = 'no bigip here';
        mockExecuteBigIpBashCmd.rejects(new Error(errMsg));
        return config.init(restWorker)
            .then(() => config.processConfigRequest(declaration))
            .then(() => {
                assert.fail('processConfigRequest() should have caught and rejected.');
            })
            .catch((err) => {
                assert.ok(true);
                assert.strictEqual(err.message, errMsg);
            });
    });

    describe('BIG-IP trigger script generation', () => {
        const originalContents = 'my trigger file contents';

        const staticComment = '# Autogenerated by F5 Failover Extension - Triggers failover';
        const triggerCommand = 'curl -u admin:admin -d {} -X POST http://localhost:8100/mgmt/shared/cloud-failover/trigger';

        function getFailoverScriptContents(command) {
            return command.substring(
                command.lastIndexOf('echo "') + 6,
                command.lastIndexOf('" >')
            );
        }

        it('should check failover script(s) get trigger call added', () => {
            mockExecuteBigIpBashCmd.resolves(originalContents);

            return config.init(restWorker)
                .then(() => config.processConfigRequest(declaration))
                .then(() => {
                    // should be called 4 times, list and update for tgactive/tgrefresh
                    assert.strictEqual(mockExecuteBigIpBashCmd.callCount, 4);
                    // get updated script contents
                    const updateScriptCommand = mockExecuteBigIpBashCmd.getCall(2).args[0];
                    const scriptContents = getFailoverScriptContents(updateScriptCommand);
                    assert.strictEqual(scriptContents, `${originalContents}\n${staticComment}\n${triggerCommand}`);
                })
                .catch(err => Promise.reject(err));
        });

        it('should check failover script(s) do not add trigger call when already added', () => {
            mockExecuteBigIpBashCmd.resolves(`${originalContents}\n${staticComment}\n${triggerCommand}`);

            return config.init(restWorker)
                .then(() => config.processConfigRequest(declaration))
                .then(() => {
                    // should be called 2 times, list for tgactive/tgrefresh
                    assert.strictEqual(mockExecuteBigIpBashCmd.callCount, 2);
                })
                .catch(err => Promise.reject(err));
        });

        it('should check legacy failover script call gets disabled', () => {
            const legacyComment = '# Disabled by F5 Failover Extension';
            const legacyFailoverCommand = '/usr/bin/f5-rest-node '
                + '/config/cloud/azure/node_modules/@f5devcentral/f5-cloud-libs-azure/scripts/failoverProvider.js';
            mockExecuteBigIpBashCmd.resolves(`${originalContents}\n${legacyFailoverCommand}`);

            return config.init(restWorker)
                .then(() => config.processConfigRequest(declaration))
                .then(() => {
                    // should be called 4 times, list and update for tgactive/tgrefresh
                    assert.strictEqual(mockExecuteBigIpBashCmd.callCount, 4);
                    // get updated script contents
                    const updateScriptCommand = mockExecuteBigIpBashCmd.getCall(2).args[0];
                    const scriptContents = getFailoverScriptContents(updateScriptCommand);
                    assert.strictEqual(
                        scriptContents,
                        `${originalContents}\n${legacyComment}\n#${legacyFailoverCommand}\n${staticComment}\n${triggerCommand}`
                    );
                })
                .catch(err => Promise.reject(err));
        });
    });
});
